/**
 * Client API Functions
 * Global functions exposed to the client-side code via google.script.run
 */

/**
 * Get all settings from PersistentStore
 */
function getAll() {
  try {
    // Ensure services are registered
    ensureServicesRegistered();
    
    // Get ConfigManager to read from CONFIG sheet
    const configManager = container.get('ConfigManager');
    if (!configManager) {
      Logger.log('[ClientAPI] ConfigManager not available, attempting direct sheet read');
      
      // Fallback: Try to read directly from APPSHEET_CONFIG sheet
      try {
        const spreadsheet = getActiveSystemSpreadsheet();
        const configSheet = spreadsheet.getSheetByName('APPSHEET_CONFIG');
        if (configSheet) {
          const data = configSheet.getDataRange().getValues();
          const result = {};
          
          // Parse APPSHEET_CONFIG sheet (skip header row)
          for (let i = 1; i < data.length; i++) {
            const key = data[i][4]; // Column E is the key
            const value = data[i][5]; // Column F is the value
            if (key) {
              result[key] = value;
            }
          }
          
          // Return config data if we got any
          if (Object.keys(result).length > 0) {
            return result;
          }
        }
      } catch (e) {
        Logger.log('[ClientAPI] Direct sheet read failed: ' + e.toString());
      }
      
      // Last resort: return minimal defaults
      return {
        SCAN_MODE: 'LABEL_ONLY', // Default as defined in SystemBootstrap
        EMAIL_LABEL: 'MOH-Time-OS',
        DEFAULT_DURATION_MINUTES: 30,
        CALENDAR_ID: 'primary'
      };
    }
    
    // Get all config values from ConfigManager
    const result = {};
    
    // Read all important config keys
    const configKeys = [
      'SCAN_MODE',
      'EMAIL_LABEL', 
      'DEFAULT_DURATION_MINUTES',
      'CALENDAR_ID',
      'MAX_DAILY_EVENTS',
      'WORK_START_HOUR',
      'WORK_END_HOUR',
      'TIMEZONE',
      'AUTO_CREATE_EVENTS'
    ];
    
    for (const key of configKeys) {
      const value = configManager.getString(key);
      if (value !== null && value !== undefined) {
        result[key] = value;
      }
    }
    
    // If we have config data, return it
    if (Object.keys(result).length > 0) {
      return result;
    }
    
    // Use PersistentStore as fallback
    const store = container.get('PersistentStore');
    if (store && store.getAll) {
      const storeResult = store.getAll();
      if (storeResult && Object.keys(storeResult).length > 0) {
        return storeResult;
      }
    }
    
    Logger.log('[ClientAPI] No config data found, returning minimal defaults');
    return {
      SCAN_MODE: 'LABEL_ONLY', // CONSISTENCY FIX: Match SystemBootstrap default
      EMAIL_LABEL: 'MOH-Time-OS',
      DEFAULT_DURATION_MINUTES: 30,
      CALENDAR_ID: 'primary'
    };
    
  } catch (error) {
    Logger.log('[ClientAPI] Error in getAll: ' + error.toString());
    // Return minimal defaults on error
    return {
      SCAN_MODE: 'ZERO_TRUST_TRIAGE',
      EMAIL_LABEL: 'MOH-Time-OS',
      DEFAULT_DURATION_MINUTES: 30,
      CALENDAR_ID: 'primary'
    };
  }
}

/**
 * Get system constants for the UI
 * This function provides constants that the UI needs for operation
 */
function getConstants() {
  try {
    // Return system constants that are defined in AB_Constants.gs
    return {
      VERSION: CONSTANTS.VERSION,
      TIMEZONE: CONSTANTS.TIMEZONE,
      CACHE_DURATION: CONSTANTS.CACHE_DURATION,
      MAX_RETRIES: CONSTANTS.MAX_RETRIES,
      CIRCUIT_BREAKER_THRESHOLD: CONSTANTS.CIRCUIT_BREAKER_THRESHOLD,
      DEFAULT_BATCH_SIZE: CONSTANTS.DEFAULT_BATCH_SIZE,
      MAX_SCORE: CONSTANTS.MAX_SCORE,
      MIN_SCORE: CONSTANTS.MIN_SCORE,
      DEFAULT_ESTIMATED_MINUTES: CONSTANTS.DEFAULT_ESTIMATED_MINUTES,
      
      // Include SERVICES for UI reference
      SERVICES: SERVICES,
      
      // Include PRIORITY enums
      PRIORITY: PRIORITY,
      
      // Include sheet names
      SHEET_NAMES: SHEET_NAMES,
      
      // Include error types
      ERROR_TYPES: ERROR_TYPES
    };
  } catch (error) {
    Logger.log('[ClientAPI] Error in getConstants: ' + error.toString());
    // Return minimal constants on error
    return {
      VERSION: 'MOH_TIME_OS_v2.0',
      TIMEZONE: 'Asia/Dubai',
      CACHE_DURATION: 300000,
      MAX_RETRIES: 3
    };
  }
}

/**
 * Get daily schedule for the current user
 */
function getDailySchedule() {
  try {
    // Ensure services are registered
    ensureServicesRegistered();
    
    // Check if services exist before using them
    if (!container.has('BatchOperations')) {
      Logger.log('[ClientAPI] BatchOperations not available');
      return [];
    }
    
    const batchOps = container.get('BatchOperations');
    if (!batchOps || !batchOps.getAllActions) {
      Logger.log('[ClientAPI] BatchOperations missing getAllActions method');
      return [];
    }
    
    // Get today's date range
    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
    const todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
    
    // Get all tasks from ACTIONS sheet
    const allTasks = batchOps.getAllActions();
    
    // Filter for today's scheduled tasks
    const todayTasks = allTasks.filter(task => {
      if (!task.scheduled_start) return false;
      const scheduledDate = new Date(task.scheduled_start);
      return scheduledDate >= todayStart && scheduledDate <= todayEnd;
    });
    
    // Sort by scheduled time
    todayTasks.sort((a, b) => {
      const dateA = new Date(a.scheduled_start);
      const dateB = new Date(b.scheduled_start);
      return dateA - dateB;
    });
    
    return todayTasks;
  } catch (error) {
    Logger.log('[ClientAPI] Error in getDailySchedule: ' + error.toString());
    return [];
  }
}

/**
 * Get all tasks
 */
function getAllTasks() {
  try {
    // Ensure services are registered
    ensureServicesRegistered();
    
    // Check if services exist before using them
    if (!container.has('BatchOperations')) {
      Logger.log('[ClientAPI] BatchOperations not available');
      return [];
    }
    
    const batchOps = container.get('BatchOperations');
    if (!batchOps || !batchOps.getAllActions) {
      Logger.log('[ClientAPI] BatchOperations missing getAllActions method');
      return [];
    }
    
    // Get all tasks from ACTIONS sheet
    const allTasks = batchOps.getAllActions();
    
    // Add logging to check the number of tasks retrieved
    Logger.log(`[ClientAPI] getAllTasks: Retrieved ${allTasks.length} tasks from BatchOperations.`);
    
    return allTasks;
  } catch (error) {
    Logger.log('[ClientAPI] Error in getAllTasks: ' + error.toString());
    return [];
  }
}

/**
 * Ensure system is initialized (helper for client functions)
 */
function ensureSystemInitialized() {
  try {
    // Use the global ensureServicesRegistered function
    ensureServicesRegistered();
    
    // Check if SystemManager needs initialization
    if (container.has('SystemManager')) {
      const systemManager = container.get('SystemManager');
      if (systemManager && typeof systemManager.isInitialized === 'function' && !systemManager.isInitialized()) {
        systemManager.initialize();
      }
    }
  } catch (error) {
    Logger.log('[ClientAPI] System initialization error: ' + error.toString());
  }
}

/**
 * Test function 1: Check if container exists
 */
function testContainer() {
  try {
    return {
      exists: typeof container !== 'undefined',
      hasMethod: typeof container !== 'undefined' && typeof container.has === 'function',
      message: 'Container check complete'
    };
  } catch (error) {
    return { error: error.toString() };
  }
}

/**
 * Test function 2: Check if services can be registered
 */
function testClientServiceRegistration() {
  try {
    // Use the global ensureServicesRegistered function
    const registered = ensureServicesRegistered();
    
    return {
      success: true,
      hasPersistentStore: container.has('PersistentStore'),
      hasBatchOps: container.has('BatchOperations'),
      message: 'Services registered successfully'
    };
  } catch (error) {
    return { 
      error: error.toString(),
      stack: error.stack
    };
  }
}

/**
 * Test function 3: Simple data return without initialization
 */
function testSimpleReturn() {
  return {
    SCAN_MODE: 'ZERO_TRUST_TRIAGE',
    EMAIL_LABEL: 'MOH-Time-OS', 
    DEFAULT_DURATION_MINUTES: 30,
    CALENDAR_ID: 'primary',
    test: true
  };
}