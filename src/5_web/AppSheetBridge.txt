/**
 * MOH TIME OS v2.0 - APPSHEET BRIDGE
 *
 * Handles GET requests for AppSheet integration and external API access.
 * Provides configuration and status endpoints for external systems.
 * Returns structured JSON responses with proper error handling.
 *
 * Original lines: 7943-7994 from scriptA.js
 */

class AppSheetBridge {
  constructor(configManager, systemManager) {
    this.configManager = configManager;
    this.systemManager = systemManager;
  }

  doGet(e) {
    try {
      const endpoint = e.parameter.endpoint || SHEET_NAMES.STATUS;

      switch (endpoint) {
      case 'config':
        return this._handleConfigRequest();
      case 'status':
        return this._handleStatusRequest();
      default:
        return this._createResponse({ error: 'Unknown endpoint' }, 400);
      }
    } catch (error) {
      // OBJ_SENTINEL_NULL_RETHROW_FATAL profile
      // TEST: TEST_SILENT_065_DOGET
      LoggerFacade.error('AppSheetBridge', 'doGet failed', {
        error: error.message,
        stack: error.stack,
        context: 'doGet'
      });

      if (error.name === 'DatabaseError' || error.name === 'ConfigurationError') {
        throw error;
      }

      return null;
    }
  }

  _handleConfigRequest() {
    const config = {
      circuit_breaker_threshold: this.configManager.getNumber('CIRCUIT_BREAKER_THRESHOLD', 5),
      scheduler_interval_minutes: this.configManager.getNumber('SCHEDULER_INTERVAL_MINUTES', 15),
      email_batch_size: this.configManager.getNumber('EMAIL_INGESTION_BATCH_SIZE', 50),
      work_hours: this.configManager.getJSON('WORK_HOURS', { start: '10:00', end: '18:00' }),
      score_weights: this.configManager.getJSON('SCORE_WEIGHTS', { deadline: 0.5, priority: 0.3, context: 0.2 })
    };

    return this._createResponse(config, 200);
  }

  _handleStatusRequest() {
    const status = this.systemManager.getSystemStatus();
    return this._createResponse(status, 200);
  }

  _createResponse(data, statusCode = 200) {
    const response = {
      status: statusCode,
      data: data,
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };

    return ContentService
      .createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * ========================================================================
 * APPSHEET WRAPPER FUNCTIONS
 * Global functions callable via Apps Script API from AppSheet
 * ========================================================================
 */

/**
 * Auto-initialization guard for AppSheet functions
 * Ensures system is initialized before accessing services
 *
 * AppSheet functions can be called at any time (manually, via API, via trigger)
 * without guarantee that completeSetup() has been run. This guard ensures
 * all required services are registered before proceeding.
 *
 * Uses comprehensive check across all service layers to detect partial initialization.
 */
function ensureSystemInitialized() {
  // Check representative services across all dependency layers
  // If ANY are missing, we need full registration
  const criticalServices = [
    SERVICES.BatchOperations,        // Layer 1: Core operations
    SERVICES.EmailIngestionEngine,   // Layer 2: Email processing
    SERVICES.IntelligentScheduler,   // Layer 3: Scheduling
    SERVICES.SystemManager,          // Layer 4: System management
    SERVICES.HumanStateManager,      // Layer 5: Human state
    SERVICES.ConfigManager           // Layer 6: Configuration
  ];

  // Check if ALL critical services are registered
  const allRegistered = criticalServices.every(function(service) {
    return hasService(service);
  });

  if (!allRegistered) {
    LoggerFacade.info('AppSheetBridge', 'Auto-initializing system for AppSheet call');

    try {
      // Ensure services are registered (this is idempotent and fast if already registered)
      ensureServicesRegistered();

      LoggerFacade.info('AppSheetBridge', 'System auto-initialization completed');
    } catch (error) {
      LoggerFacade.error('AppSheetBridge', 'Auto-initialization failed', {
        error: error.message,
        stack: error.stack
      });
      throw new Error('System initialization failed: ' + error.message);
    }
  }
}

/**
 * Wrapper 1: Run scheduling cycle
 * Triggers intelligent scheduling with optional task filtering
 *
 * @param {Object} params - Scheduling parameters
 * @param {string} params.taskId - Optional specific task ID to schedule
 * @param {string} params.priority - Optional priority filter
 * @param {boolean} params.dryRun - Test mode without writing (default: false)
 * @param {string} params.mode - "immediate" | "batch" | "weekly_optimization"
 * @param {string} params.startDate - For weekly optimization (ISO date)
 * @param {string} params.endDate - For weekly optimization (ISO date)
 * @param {boolean} params.optimize - Extra optimization pass (default: false)
 * @returns {Object} Result with scheduled count, conflicts, etc.
 */
function appsheet_runScheduling(params) {
  try {
    // ensureSystemInitialized();

    params = params || {};
    const scheduler = getService(SERVICES.IntelligentScheduler);

    const result = scheduler.runSchedulingCycle({
      dryRun: params.dryRun || false,
      taskId: params.taskId,
      priority: params.priority
    });

    return {
      success: true,
      scheduled: result.scheduled || 0,
      conflicts: result.conflicts || 0,
      rescheduled: result.rescheduled || 0,
      skipped: result.skipped || [],
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };

  } catch (error) {
    // RETHROW_WITH_LOG profile
    // TEST: TEST_SILENT_066_APPSHEET_RUNSCHEDULING
    LoggerFacade.error('AppSheetBridge', 'appsheet_runScheduling failed', {
      error: error.message,
      stack: error.stack,
      context: 'appsheet_runScheduling'
    });

    throw error;
  }
}

/**
 * Wrapper 2: Process emails
 * Triggers email triage cycle to extract tasks from inbox
 *
 * @param {Object} params - Email processing parameters
 * @param {number} params.maxEmails - Max emails to process (default: 20)
 * @param {string} params.source - Tracking source
 * @param {string} params.timestamp - Request timestamp
 * @returns {Object} Result with processed count, proposals created
 */
function appsheet_processEmails(params) {
  try {
    // ensureSystemInitialized();

    params = params || {};
    const emailEngine = getService(SERVICES.EmailIngestionEngine);

    const result = emailEngine.processUnreadEmails();

    return {
      success: true,
      processed: result.processed || 0,
      approved: result.approved || 0,
      ignored: result.ignored || 0,
      proposals: result.proposals_created || [],
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };

  } catch (error) {
    // RETHROW_WITH_LOG profile
    // TEST: TEST_SILENT_067_APPSHEET_PROCESSEMAILS
    LoggerFacade.error('AppSheetBridge', 'appsheet_processEmails failed', {
      error: error.message,
      stack: error.stack,
      context: 'appsheet_processEmails'
    });

    throw error;
  }
}

/**
 * Wrapper 3: Update human state
 * Records user energy/focus/mood and optionally triggers rescheduling
 *
 * @param {Object} params - Human state parameters
 * @param {number} params.energy - Energy level 1-5
 * @param {number} params.focus - Focus level 1-5
 * @param {string} params.mood - Mood enum value
 * @param {number} params.stress - Stress level 1-5
 * @param {boolean} params.autoReschedule - Trigger rescheduling (default: false)
 * @param {string} params.timestamp - State timestamp
 * @returns {Object} Result with state updated, tasks rescheduled
 */
function appsheet_updateHumanState(params) {
  try {
    // ensureSystemInitialized();

    params = params || {};
    const humanStateManager = getService(SERVICES.HumanStateManager);

    // Record the state
    const stateRecorded = humanStateManager.recordHumanState({
      energy: params.energy || 3,
      focus: params.focus || 3,
      mood: params.mood || 'NEUTRAL',
      stress: params.stress || 3,
      notes: params.notes || ''
    });

    let rescheduled = 0;

    // Optionally trigger rescheduling
    if (params.autoReschedule && stateRecorded) {
      try {
        const scheduler = getService(SERVICES.IntelligentScheduler);
        const scheduleResult = scheduler.runSchedulingCycle({ dryRun: false });
        rescheduled = scheduleResult.rescheduled || 0;
      } catch (scheduleError) {
        // RETHROW_WITH_LOG profile
        // TEST: TEST_SILENT_074_APPSHEET_UPDATEHUMANSTATE_NESTED
        LoggerFacade.error('AppSheetBridge', 'Auto-reschedule failed', {
          error: scheduleError.message,
          stack: scheduleError.stack,
          context: 'appsheet_updateHumanState_autoReschedule'
        });

        throw scheduleError;
      }
    }

    return {
      success: true,
      state_updated: stateRecorded,
      rescheduled: rescheduled,
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };

  } catch (error) {
    // RETHROW_WITH_LOG profile
    // TEST: TEST_SILENT_068_APPSHEET_UPDATEHUMANSTATE
    LoggerFacade.error('AppSheetBridge', 'appsheet_updateHumanState failed', {
      error: error.message,
      stack: error.stack,
      context: 'appsheet_updateHumanState'
    });

    throw error;
  }
}

/**
 * Wrapper 4: Approve proposal
 * Approves a task proposal, creates action, and schedules it
 *
 * @param {Object} params - Approval parameters
 * @param {string} params.proposalId - Required: proposal_id to approve
 * @returns {Object} Result with created action_id and scheduling status
 */
function appsheet_approveProposal(params) {
  try {
    // ensureSystemInitialized();

    if (!params || !params.proposalId) {
      throw new Error('proposalId is required');
    }

    const batchOps = getService(SERVICES.BatchOperations);
    const scheduler = getService(SERVICES.IntelligentScheduler);

    // Find the proposal
    const proposals = batchOps.getRowsByFilter(SHEET_NAMES.PROPOSED_TASKS, {
      proposal_id: params.proposalId
    });

    if (proposals.length === 0) {
      throw new Error('Proposal not found: ' + params.proposalId);
    }

    const headers = batchOps.getHeaders(SHEET_NAMES.PROPOSED_TASKS);
    const proposal = proposals[0];

    // Extract proposal data
    const titleIdx = headers.indexOf('parsed_title');
    const laneIdx = headers.indexOf('suggested_lane');
    const confidenceIdx = headers.indexOf('confidence_score');

    // Create action from proposal
    const actionId = 'ACT_' + Date.now();
    const newAction = [
      actionId,
      'PENDING',
      'MEDIUM',
      TimeZoneAwareDate.toISOString(new Date()),
      TimeZoneAwareDate.toISOString(new Date()),
      proposal[titleIdx] || 'Untitled Task',
      '',
      proposal[laneIdx] || '',
      30,
      '',
      '',
      '',
      '',
      'email',
      params.proposalId,
      '',
      '',
      0,
      '',
      0,
      '',
      'MEDIUM',
      'MEDIUM',
      0
    ];

    batchOps.appendRows(SHEET_NAMES.ACTIONS, [newAction]);

    // Update proposal status
    batchOps.updateRowById(SHEET_NAMES.PROPOSED_TASKS, params.proposalId, {
      status: 'ACCEPTED',
      processed_at: TimeZoneAwareDate.toISOString(new Date())
    });

    // Try to schedule
    let scheduled = false;
    try {
      const scheduleResult = scheduler.runSchedulingCycle({
        taskId: actionId,
        dryRun: false
      });
      scheduled = (scheduleResult.scheduled || 0) > 0;
    } catch (scheduleError) {
      // RETHROW_WITH_LOG profile
      // TEST: TEST_SILENT_075_APPSHEET_APPROVEPROPOSAL_NESTED
      LoggerFacade.error('AppSheetBridge', 'Scheduling failed after proposal approval', {
        error: scheduleError.message,
        stack: scheduleError.stack,
        context: 'appsheet_approveProposal_scheduling'
      });

      throw scheduleError;
    }

    return {
      success: true,
      action_id: actionId,
      scheduled: scheduled,
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };

  } catch (error) {
    // RETHROW_WITH_LOG profile
    // TEST: TEST_SILENT_069_APPSHEET_APPROVEPROPOSAL
    LoggerFacade.error('AppSheetBridge', 'appsheet_approveProposal failed', {
      error: error.message,
      stack: error.stack,
      context: 'appsheet_approveProposal'
    });

    throw error;
  }
}

/**
 * Wrapper 5: Get system status
 * Returns current system health and metrics
 *
 * @returns {Object} System health, services status, metrics
 */
function appsheet_getSystemStatus() {
  try {
    // ensureSystemInitialized();

    const systemManager = getService(SERVICES.SystemManager);
    const status = systemManager.getSystemStatus();

    return {
      success: true,
      data: {  // Wrap in data object - client expects response.data
        healthy: status.healthy || false,
        health: status.healthy ? 'HEALTHY' : 'UNHEALTHY',
        services: status.services || {},
        metrics: status.metrics || {},
        timestamp: TimeZoneAwareDate.toISOString(new Date()),
        scheduled: 0,
        health_score: 100
      }
    };

  } catch (error) {
    // RETHROW_WITH_LOG profile
    // TEST: TEST_SILENT_070_APPSHEET_GETSYSTEMSTATUS
    LoggerFacade.error('AppSheetBridge', 'appsheet_getSystemStatus failed', {
      error: error.message,
      stack: error.stack,
      context: 'appsheet_getSystemStatus'
    });

    throw error;
  }
}

/**
 * Wrapper 6: Handle new record
 * Processes new record created in AppSheet
 *
 * @param {Object} params - New record parameters
 * @param {string} params.table - Table name
 * @param {string} params.rowId - Primary key value
 * @param {Object} params.data - Full row data
 * @returns {Object} Processing result
 */
function appsheet_handleNewRecord(params) {
  try {
    // ensureSystemInitialized();

    if (!params || !params.table || !params.rowId) {
      throw new Error('table and rowId are required');
    }

    const triggered = [];

    // Table-specific logic
    if (params.table === SHEET_NAMES.ACTIONS && params.data) {
      // New action created - try to schedule if PENDING
      if (params.data.status === 'PENDING') {
        try {
          const scheduler = getService(SERVICES.IntelligentScheduler);
          scheduler.runSchedulingCycle({
            taskId: params.rowId,
            dryRun: false
          });
          triggered.push('IntelligentScheduler');
        } catch (err) {
          // RETHROW_WITH_LOG profile
          // TEST: TEST_SILENT_076_APPSHEET_HANDLENEWRECORD_NESTED
          LoggerFacade.error('AppSheetBridge', 'Scheduling failed for new action', {
            error: err.message,
            stack: err.stack,
            context: 'appsheet_handleNewRecord_scheduling'
          });

          throw err;
        }
      }
    }

    return {
      success: true,
      processed: true,
      triggered: triggered,
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };

  } catch (error) {
    // RETHROW_WITH_LOG profile
    // TEST: TEST_SILENT_071_APPSHEET_HANDLENEWRECORD
    LoggerFacade.error('AppSheetBridge', 'appsheet_handleNewRecord failed', {
      error: error.message,
      stack: error.stack,
      context: 'appsheet_handleNewRecord'
    });

    throw error;
  }
}

/**
 * Wrapper 7: Handle record update
 * Processes record update from AppSheet
 *
 * @param {Object} params - Update parameters
 * @param {string} params.table - Table name
 * @param {string} params.rowId - Primary key value
 * @param {Object} params.before - Row state before update
 * @param {Object} params.after - Row state after update
 * @returns {Object} Processing result
 */
function appsheet_handleUpdate(params) {
  try {
    // ensureSystemInitialized();

    if (!params || !params.table || !params.rowId) {
      throw new Error('table and rowId are required');
    }

    let rescheduled = false;

    // Table-specific logic
    if (params.table === SHEET_NAMES.ACTIONS && params.before && params.after) {
      // Check if priority or deadline changed
      const priorityChanged = params.before.priority !== params.after.priority;
      const deadlineChanged = params.before.deadline !== params.after.deadline;

      if (priorityChanged || deadlineChanged) {
        try {
          const scheduler = getService(SERVICES.IntelligentScheduler);
          scheduler.runSchedulingCycle({ dryRun: false });
          rescheduled = true;
        } catch (err) {
          // RETHROW_WITH_LOG profile
          // TEST: TEST_SILENT_077_APPSHEET_HANDLEUPDATE_NESTED
          LoggerFacade.error('AppSheetBridge', 'Rescheduling failed after update', {
            error: err.message,
            stack: err.stack,
            context: 'appsheet_handleUpdate_rescheduling'
          });

          throw err;
        }
      }
    }

    return {
      success: true,
      rescheduled: rescheduled,
      changes_processed: true,
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };

  } catch (error) {
    // RETHROW_WITH_LOG profile
    // TEST: TEST_SILENT_072_APPSHEET_HANDLEUPDATE
    LoggerFacade.error('AppSheetBridge', 'appsheet_handleUpdate failed', {
      error: error.message,
      stack: error.stack,
      context: 'appsheet_handleUpdate'
    });

    throw error;
  }
}

/**
 * Wrapper 8: Resolve calendar conflict
 * Resolves calendar conflict by rescheduling losing tasks
 *
 * @param {Object} params - Conflict resolution parameters
 * @param {string} params.winningTask - Task ID that keeps its slot
 * @param {string} params.conflictId - Conflict event ID
 * @param {Array<string>} params.losingTasks - Task IDs to reschedule
 * @returns {Object} Rescheduling result
 */
function appsheet_resolveConflict(params) {
  try {
    // ensureSystemInitialized();

    if (!params || !params.winningTask || !params.losingTasks) {
      throw new Error('winningTask and losingTasks are required');
    }

    const batchOps = getService(SERVICES.BatchOperations);
    const scheduler = getService(SERVICES.IntelligentScheduler);

    const rescheduled = [];
    const failed = [];

    // Clear schedule for losing tasks
    params.losingTasks.forEach(taskId => {
      try {
        batchOps.updateRowById(SHEET_NAMES.ACTIONS, taskId, {
          status: 'PENDING',
          scheduled_start: '',
          scheduled_end: '',
          updated_at: TimeZoneAwareDate.toISOString(new Date())
        });
        rescheduled.push(taskId);
      } catch (err) {
        // RETHROW_WITH_LOG profile
        // TEST: TEST_SILENT_078_APPSHEET_RESOLVECONFLICT_NESTED1
        LoggerFacade.error('AppSheetBridge', 'Failed to clear schedule for losing task', {
          error: err.message,
          stack: err.stack,
          context: 'appsheet_resolveConflict_clearSchedule',
          taskId: taskId
        });

        throw err;
      }
    });

    // Try to reschedule losing tasks
    if (rescheduled.length > 0) {
      try {
        scheduler.runSchedulingCycle({ dryRun: false });
      } catch (err) {
        Logger.log('Rescheduling failed after conflict resolution: ' + err.message);
      }
    }

    return {
      success: true,
      rescheduled: rescheduled,
      failed: failed,
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };

  } catch (error) {
    // RETHROW_WITH_LOG profile
    // TEST: TEST_SILENT_073_APPSHEET_RESOLVECONFLICT
    LoggerFacade.error('AppSheetBridge', 'appsheet_resolveConflict failed', {
      error: error.message,
      stack: error.stack,
      context: 'appsheet_resolveConflict'
    });

    throw error;
  }
}

/**
 * ========================================================================
 * NEW WEBAPP FUNCTIONS FOR UI INTEGRATION
 * These functions are called from DayPlanner.html via google.script.run
 * ========================================================================
 */

/**
 * Get current user context for the UI
 * @returns {Object} User information and preferences
 */
function getCurrentUser() {
  try {
    const email = Session.getActiveUser().getEmail() || 'anonymous@system';
    const timezone = Session.getScriptTimeZone();
    const locale = Session.getActiveUserLocale();
    
    // Get user preferences
    const userProps = PropertiesService.getUserProperties();
    
    return {
      email: email,
      timezone: timezone,
      locale: locale,
      preferences: {
        theme: userProps.getProperty('theme') || 'light',
        preferredLane: userProps.getProperty('preferred_lane') || LANE.OPERATIONAL,
        defaultPriority: userProps.getProperty('default_priority') || PRIORITY.MEDIUM
      }
    };
    
  } catch (error) {
    return {
      email: 'anonymous@system',
      timezone: 'UTC',
      locale: 'en',
      preferences: {}
    };
  }
}

/**
 * Validate authentication token
 * @param {Object} params - { token: string }
 * @returns {boolean} True if token is valid
 */
function appsheet_validateToken(params) {
  try {
    if (!params || !params.token) {
      return false;
    }
    
    // Try SecureWebAppAuth service first
    const auth = getService(SERVICES.SecureWebAppAuth);
    if (auth && auth.validateToken) {
      return auth.validateToken(params.token);
    }
    
    // Fallback to PropertiesService
    const validToken = PropertiesService.getScriptProperties().getProperty('WEB_AUTH_TOKEN');
    return params.token === validToken;
    
  } catch (error) {
    return false;
  }
}

/**
 * Get dashboard data including today's tasks and energy state
 * @param {Object} params - { view: 'today' | 'scheduled' }
 * @returns {Object} Dashboard data
 */
function appsheet_getMyDay(params) {
  try {
    // ensureSystemInitialized();
    
    const batchOps = getService(SERVICES.BatchOperations);
    const humanState = getService(SERVICES.HumanStateManager);
    const scheduler = getService(SERVICES.IntelligentScheduler);
    
    // Determine view type
    const view = params && params.view || 'today';
    
    // Get current date boundaries
    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
    const todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
    
    // Get all tasks from ACTIONS sheet
    const allTasks = batchOps.getAllActions();
    
    // Filter for today's tasks
    const todayTasks = allTasks.filter(function(task) {
      if (view === 'today') {
        // Tasks scheduled for today
        if (task.scheduled_start) {
          const taskStart = new Date(task.scheduled_start);
          return taskStart >= todayStart && taskStart <= todayEnd;
        }
        // Or tasks that are IN_PROGRESS
        return task.status === STATUS.IN_PROGRESS;
      } else if (view === 'scheduled') {
        // All scheduled tasks
        return task.status === STATUS.SCHEDULED;
      }
      return false;
    });
    
    // Count tasks by status
    const completedToday = todayTasks.filter(function(t) {
      return t.status === STATUS.COMPLETED && 
        t.completed_date && 
        new Date(t.completed_date) >= todayStart;
    }).length;
    
    const inProgress = todayTasks.filter(function(t) {
      return t.status === STATUS.IN_PROGRESS;
    }).length;
    
    // Get high priority tasks (top 5)
    const highPriorityTasks = todayTasks
      .filter(function(t) {
        return [PRIORITY.CRITICAL, PRIORITY.URGENT, PRIORITY.HIGH].indexOf(t.priority) !== -1;
      })
      .sort(function(a, b) {
        const priorityOrder = [PRIORITY.CRITICAL, PRIORITY.URGENT, PRIORITY.HIGH];
        return priorityOrder.indexOf(a.priority) - priorityOrder.indexOf(b.priority);
      })
      .slice(0, 5);
    
    // Get current energy state
    const currentEnergy = humanState.getCurrentHumanState();
    
    // Get pending proposals count by filtering all actions
    const allActions = batchOps.getAllActions();
    const proposals = allActions.filter(function(task) {
      return task.status === STATUS.PROPOSED || task.status === STATUS.PENDING;
    });
    
    // Calculate completion probability
    let completionProbability = 75; // Default
    if (scheduler && scheduler.calculateCompletionProbability) {
      completionProbability = scheduler.calculateCompletionProbability(
        todayTasks.filter(function(t) { return t.status !== STATUS.COMPLETED; }),
        currentEnergy
      );
    }
    
    // Build response
    return {
      success: true,
      data: {
        counts: {
          todayTasks: todayTasks.length,
          completedToday: completedToday,
          inProgress: inProgress,
          proposals: proposals ? proposals.length : 0
        },
        currentEnergy: currentEnergy || {
          energy_level: 5,
          focus_level: 5,
          stress_level: 5,
          mood: MOOD.NEUTRAL
        },
        highPriorityTasks: highPriorityTasks,
        todaySchedule: todayTasks.filter(function(t) { return t.scheduled_start; }),
        completionProbability: Math.round(completionProbability)
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getMyDay',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get all tasks with filtering and pagination
 * @param {Object} params - Filtering and pagination parameters
 * @returns {Object} Task list with metadata
 */
function appsheet_getAllTasks(params) {
  // Log at VERY START
  Logger.log('[getAllTasks] ==================== FUNCTION CALLED ====================');
  Logger.log('[getAllTasks] Params type: ' + typeof params);
  Logger.log('[getAllTasks] Params value: ' + JSON.stringify(params));
  Logger.log('[getAllTasks] Timestamp: ' + new Date().toISOString());
  
  try {
    Logger.log('[getAllTasks] About to call ensureSystemInitialized');
    // ensureSystemInitialized();
    Logger.log('[getAllTasks] ensureSystemInitialized completed successfully');
    
    Logger.log('[getAllTasks] Getting BatchOperations service...');
    const batchOps = getService(SERVICES.BatchOperations);
    Logger.log('[getAllTasks] BatchOps retrieved: ' + (batchOps ? 'SUCCESS' : 'NULL'));
    if (batchOps) {
      Logger.log('[getAllTasks] BatchOps has getAllActions: ' + (typeof batchOps.getAllActions === 'function'));
    }
    
    Logger.log('[getAllTasks] Getting SmartLogger service...');
    const logger = getService(SERVICES.SmartLogger);
    Logger.log('[getAllTasks] Logger retrieved: ' + (logger ? 'SUCCESS' : 'NULL'));
    
    // Get all tasks
    Logger.log('[getAllTasks] Calling batchOps.getAllActions()...');
    let tasks = batchOps.getAllActions();
    Logger.log('[getAllTasks] getAllActions returned, type: ' + typeof tasks);
    Logger.log('[getAllTasks] Is array: ' + Array.isArray(tasks));
    Logger.log('[getAllTasks] Tasks length: ' + (tasks ? tasks.length : 'NULL'));
    
    // Check first task structure for problematic values
    if (tasks && tasks.length > 0) {
      Logger.log('[getAllTasks] First task keys: ' + Object.keys(tasks[0]).join(','));
      
      const firstTask = tasks[0];
      for (const key in firstTask) {
        const value = firstTask[key];
        const valueType = typeof value;
        
        if (value === undefined) {
          Logger.log('[getAllTasks] WARNING: Field "' + key + '" is UNDEFINED');
        } else if (value === null) {
          Logger.log('[getAllTasks] Field "' + key + '" is null');
        } else if (value instanceof Date) {
          Logger.log('[getAllTasks] WARNING: Field "' + key + '" is DATE object: ' + value);
        } else if (valueType === 'function') {
          Logger.log('[getAllTasks] ERROR: Field "' + key + '" is FUNCTION');
        } else if (valueType === 'object' && !Array.isArray(value)) {
          Logger.log('[getAllTasks] Field "' + key + '" is object');
        }
      }
    }
    
    // Apply filters if provided
    if (params && params.filters) {
      const filters = params.filters;
      
      // Filter by status
      if (filters.status) {
        tasks = tasks.filter(function(t) { return t.status === filters.status; });
      }
      
      // Filter by priority
      if (filters.priority) {
        tasks = tasks.filter(function(t) { return t.priority === filters.priority; });
      }
      
      // Filter by lane
      if (filters.lane) {
        tasks = tasks.filter(function(t) { return t.lane === filters.lane; });
      }
      
      // Filter by energy required
      if (filters.energy_required) {
        tasks = tasks.filter(function(t) { return t.energy_required === filters.energy_required; });
      }
    }
    
    // Apply search if provided
    if (params && params.search) {
      const searchTerm = params.search.toLowerCase();
      tasks = tasks.filter(function(t) {
        return (t.title && t.title.toLowerCase().indexOf(searchTerm) !== -1) ||
          (t.description && t.description.toLowerCase().indexOf(searchTerm) !== -1) ||
          (t.context && t.context.toLowerCase().indexOf(searchTerm) !== -1);
      });
    }
    
    // Sort tasks
    Logger.log('[getAllTasks] Starting sort, tasks count: ' + tasks.length);
    try {
      tasks.sort(function(a, b) {
        // First by priority
        const priorityOrder = [
          PRIORITY.CRITICAL,
          PRIORITY.URGENT,
          PRIORITY.HIGH,
          PRIORITY.MEDIUM,
          PRIORITY.LOW,
          PRIORITY.MINIMAL
        ];
        
        const aPriority = priorityOrder.indexOf(a.priority);
        const bPriority = priorityOrder.indexOf(b.priority);
        
        if (aPriority !== bPriority) {
          return aPriority - bPriority;
        }
        
        // Then by created date (newest first)
        const dateA = a.created_at ? new Date(a.created_at) : null;
        const dateB = b.created_at ? new Date(b.created_at) : null;
        
        if (!dateA && !dateB) return 0;
        if (!dateA) return 1;
        if (!dateB) return -1;
        
        const diff = dateB - dateA;
        if (isNaN(diff)) {
          Logger.log('[getAllTasks] WARNING: NaN in date comparison. dateA: ' + a.created_at + ', dateB: ' + b.created_at);
          return 0;
        }
        return diff;
      });
      Logger.log('[getAllTasks] Sort completed successfully');
    } catch (sortError) {
      Logger.log('[getAllTasks] ERROR during sort: ' + sortError.toString());
      Logger.log('[getAllTasks] Sort error stack: ' + sortError.stack);
    }
    
    // Store total before pagination
    const total = tasks.length;
    
    // Apply pagination
    const offset = (params && params.offset) || 0;
    const limit = (params && params.limit) || 50;
    
    tasks = tasks.slice(offset, offset + limit);
    
    logger.log('AppSheetBridge', 'Returning ' + tasks.length + ' tasks out of ' + total + ' total');
    
    // Comprehensive pre-return validation
    Logger.log('[getAllTasks] ========== PRE-RETURN VALIDATION ==========');
    Logger.log('[getAllTasks] Final tasks length: ' + tasks.length);
    Logger.log('[getAllTasks] Total: ' + total);
    Logger.log('[getAllTasks] Offset: ' + offset);
    Logger.log('[getAllTasks] Limit: ' + limit);
    Logger.log('[getAllTasks] HasMore: ' + ((offset + limit) < total));
    
    // Test serialization BEFORE returning
    Logger.log('[getAllTasks] Testing JSON serialization...');
    const returnObj = {
      success: true,
      data: {
        tasks: tasks,
        total: total,
        offset: offset,
        limit: limit,
        hasMore: (offset + limit) < total
      }
    };
    
    try {
      const serialized = JSON.stringify(returnObj);
      Logger.log('[getAllTasks] ✓ Serialization SUCCESS, length: ' + serialized.length);
      
      // Try to deserialize to verify
      const deserialized = JSON.parse(serialized);
      Logger.log('[getAllTasks] ✓ Deserialization SUCCESS');
      Logger.log('[getAllTasks] ✓ Deserialized has success: ' + deserialized.success);
      Logger.log('[getAllTasks] ✓ Deserialized has data: ' + (deserialized.data ? 'YES' : 'NO'));
      
    } catch (serializeError) {
      Logger.log('[getAllTasks] ❌ SERIALIZATION FAILED: ' + serializeError.toString());
      Logger.log('[getAllTasks] Error name: ' + serializeError.name);
      Logger.log('[getAllTasks] Error message: ' + serializeError.message);
      
      // Deep dive to find what's failing
      try {
        JSON.stringify(tasks);
        Logger.log('[getAllTasks] Tasks array alone serializes OK');
      } catch (tasksError) {
        Logger.log('[getAllTasks] ❌ Tasks array FAILS to serialize: ' + tasksError.toString());
        
        // Find the problematic task
        for (let i = 0; i < Math.min(5, tasks.length); i++) {
          try {
            JSON.stringify(tasks[i]);
            Logger.log('[getAllTasks] Task ' + i + ' serializes OK');
          } catch (taskError) {
            Logger.log('[getAllTasks] ❌ Task ' + i + ' CANNOT serialize: ' + taskError.toString());
            
            // Find the problematic field
            for (const key in tasks[i]) {
              try {
                JSON.stringify(tasks[i][key]);
              } catch (fieldError) {
                Logger.log('[getAllTasks] ❌ Field "' + key + '" in task ' + i + ' causes serialization failure');
                Logger.log('[getAllTasks] Field type: ' + typeof tasks[i][key]);
                Logger.log('[getAllTasks] Field value: ' + String(tasks[i][key]));
              }
            }
            break;
          }
        }
      }
    }
    
    Logger.log('[getAllTasks] ========== RETURNING RESPONSE ==========');
    Logger.log('[getAllTasks] Response.success: ' + returnObj.success);
    Logger.log('[getAllTasks] Response.data exists: ' + (returnObj.data ? 'YES' : 'NO'));
    Logger.log('[getAllTasks] About to return...');
    
    return returnObj;
    
  } catch (error) {
    Logger.log('[getAllTasks] ❌❌❌ CATCH BLOCK TRIGGERED ❌❌❌');
    Logger.log('[getAllTasks] Error type: ' + typeof error);
    Logger.log('[getAllTasks] Error name: ' + error.name);
    Logger.log('[getAllTasks] Error message: ' + error.message);
    Logger.log('[getAllTasks] Error toString: ' + error.toString());
    Logger.log('[getAllTasks] Error stack: ' + error.stack);
    
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getAllTasks',
      error: error.toString(),
      params: params
    });
    
    Logger.log('[getAllTasks] Returning error response...');
    const errorResponse = {
      success: false,
      error: error.toString()
    };
    
    // Test if error response can serialize
    try {
      JSON.stringify(errorResponse);
      Logger.log('[getAllTasks] Error response CAN serialize');
    } catch (e) {
      Logger.log('[getAllTasks] Error response CANNOT serialize: ' + e.toString());
    }
    
    return errorResponse;
  }
}

/**
 * Get high priority tasks
 * @param {Object} params - { limit: number }
 * @returns {Object} High priority tasks
 */
function appsheet_getHighPriorityTasks(params) {
  try {
    // ensureSystemInitialized();
    
    const limit = (params && params.limit) || 5;
    
    // Get all tasks and filter
    const result = appsheet_getAllTasks({
      filters: { status: STATUS.SCHEDULED },
      limit: 100
    });
    
    if (!result.success) {
      return result;
    }
    
    // Filter for high priority only
    const highPriority = result.data.tasks
      .filter(function(t) {
        return [PRIORITY.CRITICAL, PRIORITY.URGENT, PRIORITY.HIGH].indexOf(t.priority) !== -1;
      })
      .slice(0, limit);
    
    return {
      success: true,
      data: {
        tasks: highPriority
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getHighPriorityTasks',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Create a new task
 * @param {Object} taskData - Task data
 * @returns {Object} Created task
 */
function appsheet_createTask(taskData) {
  try {
    // ensureSystemInitialized();
    
    const batchOps = getService(SERVICES.BatchOperations);
    const scheduler = getService(SERVICES.IntelligentScheduler);
    const logger = getService(SERVICES.SmartLogger);
    
    // Validate required fields
    if (!taskData || !taskData.title) {
      throw new Error('Task title is required');
    }
    
    // Generate unique action_id
    const actionId = 'ACT_' + Utilities.getUuid().substring(0, 8).toUpperCase();
    
    // Get current user
    const userEmail = Session.getActiveUser().getEmail() || 'webapp@system';
    
    // Build complete task object with defaults
    const newTask = {
      action_id: actionId,
      status: STATUS.PENDING,
      priority: taskData.priority || PRIORITY.MEDIUM,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      title: taskData.title.substring(0, 200), // Max 200 chars
      context: taskData.context || '',
      lane: taskData.lane || LANE.OPERATIONAL,
      estimated_minutes: taskData.estimated_minutes || 30,
      description: taskData.description || '',
      source: 'webapp',
      energy_required: taskData.energy_required || ENERGY_LEVEL.MEDIUM,
      focus_required: taskData.focus_required || 'MODERATE',
      deadline: taskData.deadline || '',
      scheduled_start: '',
      scheduled_end: '',
      completed_date: '',
      actual_minutes: '',
      estimation_accuracy: '',
      created_by: userEmail,
      assigned_to: taskData.assigned_to || userEmail,
      rollover_count: 0,
      parent_id: taskData.parent_id || '',
      dependencies: JSON.stringify(taskData.dependencies || []),
      tags: JSON.stringify(taskData.tags || [])
    };
    
    // Get the ACTIONS sheet
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    // Create row array in exact column order
    const row = [
      newTask.action_id,           // Column 0
      newTask.status,               // Column 1
      newTask.priority,             // Column 2
      newTask.created_at,           // Column 3
      newTask.updated_at,           // Column 4
      newTask.title,                // Column 5
      newTask.context,              // Column 6
      newTask.lane,                 // Column 7
      newTask.estimated_minutes,    // Column 8
      newTask.description,          // Column 9
      newTask.source,               // Column 10
      newTask.energy_required,      // Column 11
      newTask.focus_required,       // Column 12
      newTask.deadline,             // Column 13
      newTask.scheduled_start,      // Column 14
      newTask.scheduled_end,        // Column 15
      newTask.completed_date,       // Column 16
      newTask.actual_minutes,       // Column 17
      newTask.estimation_accuracy,  // Column 18
      newTask.created_by,           // Column 19
      newTask.assigned_to,          // Column 20
      newTask.rollover_count,       // Column 21
      newTask.parent_id,            // Column 22
      newTask.dependencies,         // Column 23
      newTask.tags                  // Column 24
    ];
    
    // Append the row
    sheet.appendRow(row);
    
    logger.log('AppSheetBridge', 'Created task ' + actionId + ': ' + newTask.title);
    
    // Try to schedule the task if scheduler is available
    if (scheduler && scheduler.scheduleTask) {
      try {
        const schedulingResult = scheduler.scheduleTask(newTask);
        if (schedulingResult && schedulingResult.scheduled_start) {
          // Update the task with scheduling info
          newTask.scheduled_start = schedulingResult.scheduled_start;
          newTask.scheduled_end = schedulingResult.scheduled_end;
          newTask.status = STATUS.SCHEDULED;
          
          // Update the sheet
          const lastRow = sheet.getLastRow();
          sheet.getRange(lastRow, 2).setValue(newTask.status); // Status column
          sheet.getRange(lastRow, 15).setValue(newTask.scheduled_start);
          sheet.getRange(lastRow, 16).setValue(newTask.scheduled_end);
        }
      } catch (scheduleError) {
        logger.warning('AppSheetBridge', 'Scheduling failed for ' + actionId + ': ' + scheduleError);
        // Continue - task is created even if scheduling fails
      }
    }
    
    return {
      success: true,
      data: newTask
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_createTask',
      error: error.toString(),
      taskData: taskData
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Start a task - changes status to IN_PROGRESS
 * @param {Object} params - Parameters
 * @param {string} params.taskId - Task ID to start
 * @return {Object} Result with updated task
 */
function appsheet_startTask(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params || !params.taskId) {
      throw new Error('taskId is required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    // Find the task
    const data = sheet.getDataRange().getValues();
    let taskRow = -1;
    let task = null;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.taskId) {  // action_id column
        taskRow = i + 1;  // Sheet rows are 1-indexed
        task = {
          action_id: data[i][0],
          status: data[i][1],
          priority: data[i][2],
          title: data[i][5]
        };
        break;
      }
    }
    
    if (taskRow === -1) {
      throw new Error('Task not found: ' + params.taskId);
    }
    
    // Update status and timestamps
    const now = TimeZoneAwareDate.toISOString(new Date());
    sheet.getRange(taskRow, 2).setValue(STATUS.IN_PROGRESS);  // status column
    sheet.getRange(taskRow, 5).setValue(now);  // updated_at column
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Started task ' + params.taskId);
    
    return {
      success: true,
      data: {
        action_id: params.taskId,
        status: STATUS.IN_PROGRESS,
        updated_at: now
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_startTask',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Complete a task
 * @param {Object} params - Parameters
 * @param {string} params.taskId - Task ID to complete
 * @param {number} params.actualMinutes - Actual minutes taken
 * @return {Object} Result with updated task
 */
function appsheet_completeTask(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params || !params.taskId) {
      throw new Error('taskId is required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    // Find the task
    const data = sheet.getDataRange().getValues();
    let taskRow = -1;
    let estimatedMinutes = 0;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.taskId) {  // action_id column
        taskRow = i + 1;  // Sheet rows are 1-indexed
        estimatedMinutes = data[i][8] || 30;  // estimated_minutes column
        break;
      }
    }
    
    if (taskRow === -1) {
      throw new Error('Task not found: ' + params.taskId);
    }
    
    // Calculate estimation accuracy
    const actualMinutes = params.actualMinutes || estimatedMinutes;
    const accuracy = estimatedMinutes > 0 ? (actualMinutes / estimatedMinutes) : 1;
    
    // Update task
    const now = TimeZoneAwareDate.toISOString(new Date());
    sheet.getRange(taskRow, 2).setValue(STATUS.COMPLETED);  // status column
    sheet.getRange(taskRow, 5).setValue(now);  // updated_at column
    sheet.getRange(taskRow, 17).setValue(now);  // completed_date column
    sheet.getRange(taskRow, 18).setValue(actualMinutes);  // actual_minutes column
    sheet.getRange(taskRow, 19).setValue(accuracy);  // estimation_accuracy column
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Completed task ' + params.taskId + ' in ' + actualMinutes + ' minutes');
    
    return {
      success: true,
      data: {
        action_id: params.taskId,
        status: STATUS.COMPLETED,
        completed_date: now,
        actual_minutes: actualMinutes,
        estimation_accuracy: accuracy
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_completeTask',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Snooze a task - defer it to later
 * @param {Object} params - Parameters
 * @param {string} params.taskId - Task ID to snooze
 * @param {number} params.minutes - Minutes to snooze for (default: 60)
 * @return {Object} Result with updated task
 */
function appsheet_snoozeTask(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params || !params.taskId) {
      throw new Error('taskId is required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    // Find the task
    const data = sheet.getDataRange().getValues();
    let taskRow = -1;
    let rolloverCount = 0;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.taskId) {  // action_id column
        taskRow = i + 1;  // Sheet rows are 1-indexed
        rolloverCount = data[i][21] || 0;  // rollover_count column
        break;
      }
    }
    
    if (taskRow === -1) {
      throw new Error('Task not found: ' + params.taskId);
    }
    
    // Calculate new scheduled time
    const snoozeMinutes = params.minutes || 60;
    const now = new Date();
    const newStartTime = new Date(now.getTime() + (snoozeMinutes * 60 * 1000));
    const newStartISO = TimeZoneAwareDate.toISOString(newStartTime);
    
    // Update task
    sheet.getRange(taskRow, 2).setValue(STATUS.DEFERRED);  // status column
    sheet.getRange(taskRow, 5).setValue(TimeZoneAwareDate.toISOString(now));  // updated_at column
    sheet.getRange(taskRow, 15).setValue(newStartISO);  // scheduled_start column
    sheet.getRange(taskRow, 22).setValue(rolloverCount + 1);  // rollover_count column
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Snoozed task ' + params.taskId + ' for ' + snoozeMinutes + ' minutes');
    
    return {
      success: true,
      data: {
        action_id: params.taskId,
        status: STATUS.DEFERRED,
        scheduled_start: newStartISO,
        rollover_count: rolloverCount + 1
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_snoozeTask',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Cancel a task
 * @param {Object} params - Parameters
 * @param {string} params.taskId - Task ID to cancel
 * @param {string} params.reason - Cancellation reason
 * @return {Object} Result with updated task
 */
function appsheet_cancelTask(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params || !params.taskId) {
      throw new Error('taskId is required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    // Find the task
    const data = sheet.getDataRange().getValues();
    let taskRow = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.taskId) {  // action_id column
        taskRow = i + 1;  // Sheet rows are 1-indexed
        break;
      }
    }
    
    if (taskRow === -1) {
      throw new Error('Task not found: ' + params.taskId);
    }
    
    // Update task
    const now = TimeZoneAwareDate.toISOString(new Date());
    sheet.getRange(taskRow, 2).setValue(STATUS.CANCELED);  // status column
    sheet.getRange(taskRow, 5).setValue(now);  // updated_at column
    
    // Add cancellation reason to context if provided
    if (params.reason) {
      const currentContext = sheet.getRange(taskRow, 7).getValue() || '';
      const newContext = currentContext + ' [CANCELED: ' + params.reason + ']';
      sheet.getRange(taskRow, 7).setValue(newContext);  // context column
    }
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Canceled task ' + params.taskId + (params.reason ? ': ' + params.reason : ''));
    
    return {
      success: true,
      data: {
        action_id: params.taskId,
        status: STATUS.CANCELED,
        updated_at: now
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_cancelTask',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Archive a task
 * @param {Object} params - Parameters
 * @param {string} params.taskId - Task ID to archive
 * @return {Object} Result with success status
 */
function appsheet_archiveTask(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params || !params.taskId) {
      throw new Error('taskId is required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    // Find the task
    const data = sheet.getDataRange().getValues();
    let taskRow = -1;
    let currentStatus = '';
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.taskId) {  // action_id column
        taskRow = i + 1;  // Sheet rows are 1-indexed
        currentStatus = data[i][1];  // status column
        break;
      }
    }
    
    if (taskRow === -1) {
      throw new Error('Task not found: ' + params.taskId);
    }
    
    // Only completed or canceled tasks can be archived
    if (currentStatus !== STATUS.COMPLETED && currentStatus !== STATUS.CANCELED) {
      throw new Error('Only completed or canceled tasks can be archived');
    }
    
    // Update task
    const now = TimeZoneAwareDate.toISOString(new Date());
    sheet.getRange(taskRow, 2).setValue(STATUS.ARCHIVED);  // status column
    sheet.getRange(taskRow, 5).setValue(now);  // updated_at column
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Archived task ' + params.taskId);
    
    return {
      success: true,
      data: {
        action_id: params.taskId,
        status: STATUS.ARCHIVED,
        updated_at: now
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_archiveTask',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Reschedule a task
 * @param {Object} params - Parameters
 * @param {string} params.taskId - Task ID to reschedule
 * @param {string} params.newStart - New start time (ISO string)
 * @param {number} params.duration - Duration in minutes
 * @return {Object} Result with updated schedule
 */
function appsheet_rescheduleTask(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params || !params.taskId) {
      throw new Error('taskId is required');
    }
    
    if (!params.newStart) {
      throw new Error('newStart is required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    // Find the task
    const data = sheet.getDataRange().getValues();
    let taskRow = -1;
    let estimatedMinutes = 30;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.taskId) {  // action_id column
        taskRow = i + 1;  // Sheet rows are 1-indexed
        estimatedMinutes = data[i][8] || 30;  // estimated_minutes column
        break;
      }
    }
    
    if (taskRow === -1) {
      throw new Error('Task not found: ' + params.taskId);
    }
    
    // Calculate new schedule
    const duration = params.duration || estimatedMinutes;
    const startTime = new Date(params.newStart);
    const endTime = new Date(startTime.getTime() + (duration * 60 * 1000));
    
    const newStartISO = TimeZoneAwareDate.toISOString(startTime);
    const newEndISO = TimeZoneAwareDate.toISOString(endTime);
    const now = TimeZoneAwareDate.toISOString(new Date());
    
    // Update task
    sheet.getRange(taskRow, 2).setValue(STATUS.SCHEDULED);  // status column
    sheet.getRange(taskRow, 5).setValue(now);  // updated_at column
    sheet.getRange(taskRow, 15).setValue(newStartISO);  // scheduled_start column
    sheet.getRange(taskRow, 16).setValue(newEndISO);  // scheduled_end column
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Rescheduled task ' + params.taskId + ' to ' + newStartISO);
    
    return {
      success: true,
      data: {
        action_id: params.taskId,
        status: STATUS.SCHEDULED,
        scheduled_start: newStartISO,
        scheduled_end: newEndISO,
        duration: duration
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_rescheduleTask',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get email proposals from the triage queue
 * @param {Object} params - Parameters
 * @param {string} params.status - Filter by status (PENDING, APPROVED, REJECTED)
 * @param {number} params.limit - Maximum number to return
 * @return {Object} Result with proposals array
 */
function appsheet_getProposals(params) {
  try {
    // ensureSystemInitialized();
    
    params = params || {};
    const filterStatus = params.status || 'PENDING';
    const limit = params.limit || 50;
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.PROPOSED_TASKS);
    
    if (!sheet) {
      throw new Error('PROPOSED_TASKS sheet not found');
    }
    
    const data = sheet.getDataRange().getValues();
    const proposals = [];
    
    // Skip header row
    for (let i = 1; i < data.length && proposals.length < limit; i++) {
      const row = data[i];
      const status = row[9];  // status column
      
      if (!filterStatus || status === filterStatus) {
        proposals.push({
          proposal_id: row[0],
          sender_email: row[1],
          subject: row[2],
          body: row[3],
          extracted_title: row[4],
          suggested_priority: row[5],
          suggested_lane: row[6],
          suggested_duration: row[7],
          confidence_score: row[8],
          status: row[9],
          processed_at: row[10],
          created_task_id: row[11]
        });
      }
    }
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Retrieved ' + proposals.length + ' proposals with status ' + filterStatus);
    
    return {
      success: true,
      data: proposals
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getProposals',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get pending proposals count for notification badge
 * @return {Object} Result with count
 */
function appsheet_getPendingProposalsCount() {
  try {
    // ensureSystemInitialized();
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.PROPOSED_TASKS);
    
    if (!sheet) {
      return {
        success: true,
        data: { count: 0 }
      };
    }
    
    const data = sheet.getDataRange().getValues();
    let count = 0;
    
    // Skip header row
    for (let i = 1; i < data.length; i++) {
      if (data[i][9] === PROPOSAL_STATUS.PENDING) {  // status column
        count++;
      }
    }
    
    return {
      success: true,
      data: { count: count }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getPendingProposalsCount',
      error: error.toString()
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Process a proposal - approve or reject
 * @param {Object} params - Parameters
 * @param {string} params.proposalId - Proposal ID
 * @param {string} params.action - 'approve' or 'reject'
 * @param {Object} params.taskData - Task data for approval (optional overrides)
 * @return {Object} Result with created task (if approved)
 */
function appsheet_processProposal(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params || !params.proposalId || !params.action) {
      throw new Error('proposalId and action are required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const proposalSheet = spreadsheet.getSheetByName(SHEET_NAMES.PROPOSED_TASKS);
    
    if (!proposalSheet) {
      throw new Error('PROPOSED_TASKS sheet not found');
    }
    
    // Find the proposal
    const data = proposalSheet.getDataRange().getValues();
    let proposalRow = -1;
    let proposal = null;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.proposalId) {  // proposal_id column
        proposalRow = i + 1;  // Sheet rows are 1-indexed
        proposal = {
          proposal_id: data[i][0],
          sender_email: data[i][1],
          subject: data[i][2],
          body: data[i][3],
          extracted_title: data[i][4],
          suggested_priority: data[i][5],
          suggested_lane: data[i][6],
          suggested_duration: data[i][7],
          confidence_score: data[i][8],
          status: data[i][9]
        };
        break;
      }
    }
    
    if (proposalRow === -1) {
      throw new Error('Proposal not found: ' + params.proposalId);
    }
    
    if (proposal.status !== PROPOSAL_STATUS.PENDING) {
      throw new Error('Proposal already processed: ' + proposal.status);
    }
    
    const now = TimeZoneAwareDate.toISOString(new Date());
    const logger = getService(SERVICES.SmartLogger);
    
    if (params.action === 'reject') {
      // Update proposal status
      proposalSheet.getRange(proposalRow, 10).setValue(PROPOSAL_STATUS.REJECTED);  // status column
      proposalSheet.getRange(proposalRow, 11).setValue(now);  // processed_at column
      
      logger.log('AppSheetBridge', 'Rejected proposal ' + params.proposalId);
      
      return {
        success: true,
        data: {
          proposal_id: params.proposalId,
          action: 'rejected',
          status: PROPOSAL_STATUS.REJECTED
        }
      };
    }
    
    if (params.action === 'approve') {
      // Create task from proposal
      const taskData = params.taskData || {};
      const newTaskParams = {
        title: taskData.title || proposal.extracted_title || proposal.subject,
        description: taskData.description || proposal.body,
        priority: taskData.priority || proposal.suggested_priority || PRIORITY.MEDIUM,
        lane: taskData.lane || proposal.suggested_lane || LANE.OPERATIONAL,
        estimated_minutes: taskData.estimated_minutes || proposal.suggested_duration || 30,
        source: 'email',
        created_by: proposal.sender_email
      };
      
      const createResult = appsheet_createTask(newTaskParams);
      
      if (createResult.success) {
        // Update proposal with created task ID
        proposalSheet.getRange(proposalRow, 10).setValue(PROPOSAL_STATUS.APPROVED);  // status column
        proposalSheet.getRange(proposalRow, 11).setValue(now);  // processed_at column
        proposalSheet.getRange(proposalRow, 12).setValue(createResult.data.action_id);  // created_task_id column
        
        logger.log('AppSheetBridge', 'Approved proposal ' + params.proposalId + ', created task ' + createResult.data.action_id);
        
        return {
          success: true,
          data: {
            proposal_id: params.proposalId,
            action: 'approved',
            status: PROPOSAL_STATUS.APPROVED,
            created_task: createResult.data
          }
        };
      } else {
        throw new Error('Failed to create task: ' + createResult.error);
      }
    }
    
    throw new Error('Invalid action: ' + params.action);
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_processProposal',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Log energy/human state
 * @param {Object} params - Energy state data
 * @param {number} params.energy_level - Energy level 1-10
 * @param {number} params.focus_level - Focus level 1-10
 * @param {number} params.stress_level - Stress level 1-10
 * @param {string} params.mood - Current mood
 * @param {string} params.notes - Optional notes
 * @return {Object} Result with success status
 */
function appsheet_logEnergyState(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params) {
      throw new Error('Energy state data is required');
    }
    
    // Validate energy levels
    const energyLevel = Math.max(1, Math.min(10, params.energy_level || 5));
    const focusLevel = Math.max(1, Math.min(10, params.focus_level || 5));
    const stressLevel = Math.max(1, Math.min(10, params.stress_level || 5));
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.HUMAN_STATE);
    
    if (!sheet) {
      throw new Error('HUMAN_STATE sheet not found');
    }
    
    // Generate state ID
    const stateId = 'STATE_' + Utilities.getUuid().substring(0, 8).toUpperCase();
    const timestamp = TimeZoneAwareDate.toISOString(new Date());
    const user = getCurrentUser();
    
    // Create row in exact column order
    const row = [
      stateId,                      // Column 0: state_id
      timestamp,                    // Column 1: timestamp
      energyLevel,                  // Column 2: energy_level
      focusLevel,                   // Column 3: focus_level
      params.mood || MOOD.NEUTRAL, // Column 4: mood
      stressLevel,                  // Column 5: stress_level
      params.current_context || '', // Column 6: current_context
      params.notes || ''            // Column 7: notes
    ];
    
    // Append the row
    sheet.appendRow(row);
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Logged energy state: Energy=' + energyLevel + ', Focus=' + focusLevel + ', Stress=' + stressLevel);
    
    // Try to trigger rescheduling if scheduler is available
    const scheduler = getService(SERVICES.IntelligentScheduler);
    let rescheduled = 0;
    if (scheduler && scheduler.runSchedulingCycle) {
      try {
        const scheduleResult = scheduler.runSchedulingCycle({ dryRun: false });
        rescheduled = scheduleResult.rescheduled || 0;
      } catch (scheduleError) {
        logger.warning('AppSheetBridge', 'Auto-reschedule failed: ' + scheduleError);
      }
    }
    
    return {
      success: true,
      data: {
        state_id: stateId,
        timestamp: timestamp,
        energy_level: energyLevel,
        focus_level: focusLevel,
        stress_level: stressLevel,
        mood: params.mood || MOOD.NEUTRAL,
        tasks_rescheduled: rescheduled
      }
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_logEnergyState',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get energy state history
 * @param {Object} params - Parameters
 * @param {number} params.days - Number of days of history (default: 7)
 * @return {Object} Result with energy history array
 */
function appsheet_getEnergyHistory(params) {
  try {
    // ensureSystemInitialized();
    
    params = params || {};
    const days = params.days || 7;
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.HUMAN_STATE);
    
    if (!sheet) {
      return {
        success: true,
        data: []
      };
    }
    
    // Calculate date range
    const now = new Date();
    const cutoffDate = new Date(now.getTime() - (days * 24 * 60 * 60 * 1000));
    
    const data = sheet.getDataRange().getValues();
    const history = [];
    
    // Skip header row and collect recent entries
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const timestamp = row[1];
      
      if (timestamp) {
        const entryDate = new Date(timestamp);
        if (entryDate >= cutoffDate) {
          history.push({
            state_id: row[0],
            timestamp: row[1],
            energy_level: row[2],
            focus_level: row[3],
            mood: row[4],
            stress_level: row[5],
            current_context: row[6],
            notes: row[7]
          });
        }
      }
    }
    
    // Sort by timestamp descending
    history.sort(function(a, b) {
      return new Date(b.timestamp) - new Date(a.timestamp);
    });
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Retrieved ' + history.length + ' energy states for past ' + days + ' days');
    
    return {
      success: true,
      data: history
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getEnergyHistory',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get calendar events for scheduling view
 * @param {Object} params - Parameters
 * @param {string} params.startDate - Start date (ISO string)
 * @param {string} params.endDate - End date (ISO string)
 * @return {Object} Result with events array
 */
function appsheet_getCalendarEvents(params) {
  try {
    // ensureSystemInitialized();
    
    params = params || {};
    const now = new Date();
    const startDate = params.startDate ? new Date(params.startDate) : now;
    const endDate = params.endDate ? new Date(params.endDate) : new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000));
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.CALENDAR_PROJECTION);
    
    const events = [];
    
    if (sheet) {
      const data = sheet.getDataRange().getValues();
      
      // Skip header row
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        const eventStart = row[3] ? new Date(row[3]) : null;
        const eventEnd = row[4] ? new Date(row[4]) : null;
        
        if (eventStart && eventStart >= startDate && eventStart <= endDate) {
          events.push({
            event_id: row[0],
            title: row[1],
            event_type: row[2],
            start_time: row[3],
            end_time: row[4],
            all_day: row[5],
            location: row[6],
            description: row[7],
            calendar_id: row[8],
            is_recurring: row[9],
            attendees: row[10] ? JSON.parse(row[10]) : [],
            task_id: row[11],
            is_blocked: row[12],
            source: row[13]
          });
        }
      }
    }
    
    // Sort by start time
    events.sort(function(a, b) {
      return new Date(a.start_time) - new Date(b.start_time);
    });
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Retrieved ' + events.length + ' calendar events');
    
    return {
      success: true,
      data: events
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getCalendarEvents',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get current settings
 * @return {Object} Result with settings object
 */
function appsheet_getSettings() {
  try {
    // ensureSystemInitialized();
    
    const configManager = getService(SERVICES.ConfigManager);
    
    if (!configManager) {
      throw new Error('ConfigManager service not available');
    }
    
    // Get all relevant settings
    const settings = {
      // Work hours
      work_start_time: configManager.getConfig('WORK_START_TIME', '09:00'),
      work_end_time: configManager.getConfig('WORK_END_TIME', '17:00'),
      work_days: configManager.getConfig('WORK_DAYS', 'Mon,Tue,Wed,Thu,Fri'),
      
      // Break settings
      break_duration: configManager.getConfig('BREAK_DURATION_MINUTES', 15),
      lunch_duration: configManager.getConfig('LUNCH_DURATION_MINUTES', 60),
      lunch_time: configManager.getConfig('LUNCH_TIME', '12:00'),
      
      // Scheduling preferences
      default_task_duration: configManager.getConfig('DEFAULT_TASK_DURATION', 30),
      buffer_between_tasks: configManager.getConfig('BUFFER_BETWEEN_TASKS', 5),
      max_consecutive_hours: configManager.getConfig('MAX_CONSECUTIVE_HOURS', 2),
      
      // Energy management
      auto_reschedule_enabled: configManager.getConfig('AUTO_RESCHEDULE_ENABLED', true),
      energy_check_frequency: configManager.getConfig('ENERGY_CHECK_FREQUENCY', 60),
      
      // UI preferences
      theme: configManager.getConfig('UI_THEME', 'light'),
      notifications_enabled: configManager.getConfig('NOTIFICATIONS_ENABLED', true),
      auto_refresh_interval: configManager.getConfig('AUTO_REFRESH_INTERVAL', 30),
      
      // Email processing
      email_processing_enabled: configManager.getConfig('EMAIL_PROCESSING_ENABLED', true),
      email_check_frequency: configManager.getConfig('EMAIL_CHECK_FREQUENCY', 15)
    };
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Retrieved system settings');
    
    return {
      success: true,
      data: settings
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getSettings',
      error: error.toString()
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Update settings
 * @param {Object} params - Settings to update
 * @return {Object} Result with updated settings
 */
function appsheet_updateSettings(params) {
  try {
    // ensureSystemInitialized();
    
    if (!params) {
      throw new Error('Settings data is required');
    }
    
    const configManager = getService(SERVICES.ConfigManager);
    
    if (!configManager) {
      throw new Error('ConfigManager service not available');
    }
    
    const updatedSettings = {};
    
    // Update each provided setting
    const settingMappings = {
      work_start_time: 'WORK_START_TIME',
      work_end_time: 'WORK_END_TIME',
      work_days: 'WORK_DAYS',
      break_duration: 'BREAK_DURATION_MINUTES',
      lunch_duration: 'LUNCH_DURATION_MINUTES',
      lunch_time: 'LUNCH_TIME',
      default_task_duration: 'DEFAULT_TASK_DURATION',
      buffer_between_tasks: 'BUFFER_BETWEEN_TASKS',
      max_consecutive_hours: 'MAX_CONSECUTIVE_HOURS',
      auto_reschedule_enabled: 'AUTO_RESCHEDULE_ENABLED',
      energy_check_frequency: 'ENERGY_CHECK_FREQUENCY',
      theme: 'UI_THEME',
      notifications_enabled: 'NOTIFICATIONS_ENABLED',
      auto_refresh_interval: 'AUTO_REFRESH_INTERVAL',
      email_processing_enabled: 'EMAIL_PROCESSING_ENABLED',
      email_check_frequency: 'EMAIL_CHECK_FREQUENCY'
    };
    
    for (const key in params) {
      if (settingMappings[key]) {
        const configKey = settingMappings[key];
        configManager.setConfig(configKey, params[key]);
        updatedSettings[key] = params[key];
      }
    }
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Updated ' + Object.keys(updatedSettings).length + ' settings');
    
    return {
      success: true,
      data: updatedSettings
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_updateSettings',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get batch data for initial load
 * @param {Object} params - Parameters
 * @return {Object} Result with all data needed for UI initialization
 */
function appsheet_getBatchData(params) {
  try {
    // ensureSystemInitialized();
    
    params = params || {};
    
    // Collect all data in parallel
    const batchData = {
      user: getCurrentUser(),
      dashboard: appsheet_getMyDay({ view: 'today' }).data,
      tasks: appsheet_getAllTasks({ 
        filters: { status: STATUS.SCHEDULED }, 
        limit: 100 
      }).data,
      proposals_count: appsheet_getPendingProposalsCount().data.count,
      energy_history: appsheet_getEnergyHistory({ days: 1 }).data,
      settings: appsheet_getSettings().data,
      timestamp: TimeZoneAwareDate.toISOString(new Date())
    };
    
    const logger = getService(SERVICES.SmartLogger);
    logger.log('AppSheetBridge', 'Retrieved batch data for UI initialization');
    
    return {
      success: true,
      data: batchData
    };
    
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getBatchData',
      error: error.toString(),
      params: params
    });
    
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Export all task data
 * @return {Object} Result with all tasks for export
 */
function appsheet_exportData() {
  try {
    // ensureSystemInitialized();
    const batchOps = getService(SERVICES.BatchOperations);
    const allTasks = batchOps.getAllActions();
    
    return {
      success: true,
      data: {
        tasks: allTasks,
        exported_at: TimeZoneAwareDate.toISOString(new Date()),
        count: allTasks.length
      }
    };
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_exportData',
      error: error.toString()
    });
    
    return { 
      success: false, 
      error: error.toString() 
    };
  }
}

/**
 * Get a single task by ID
 * @param {Object} params - Parameters
 * @param {string} params.taskId - Task ID to retrieve
 * @return {Object} Result with task data
 */
function appsheet_getTask(params) {
  try {
    // ensureSystemInitialized();
    if (!params || !params.taskId) {
      throw new Error('taskId is required');
    }
    
    const batchOps = getService(SERVICES.BatchOperations);
    const allTasks = batchOps.getAllActions();
    const task = allTasks.find(function(t) { 
      return t.action_id === params.taskId; 
    });
    
    if (!task) {
      throw new Error('Task not found: ' + params.taskId);
    }
    
    return {
      success: true,
      data: task
    };
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_getTask',
      error: error.toString(),
      params: params
    });
    
    return { 
      success: false, 
      error: error.toString() 
    };
  }
}

/**
 * Delete a task
 * @param {Object} params - Parameters
 * @param {string} params.taskId - Task ID to delete
 * @return {Object} Result with deletion status
 */
function appsheet_deleteTask(params) {
  try {
    // ensureSystemInitialized();
    if (!params || !params.taskId) {
      throw new Error('taskId is required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    const data = sheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.taskId) {  // action_id column
        sheet.deleteRow(i + 1);  // Sheet rows are 1-indexed
        
        const logger = getService(SERVICES.SmartLogger);
        logger.log('AppSheetBridge', 'Deleted task ' + params.taskId);
        
        return {
          success: true,
          data: { 
            deleted: params.taskId,
            timestamp: TimeZoneAwareDate.toISOString(new Date())
          }
        };
      }
    }
    
    throw new Error('Task not found: ' + params.taskId);
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_deleteTask',
      error: error.toString(),
      params: params
    });
    
    return { 
      success: false, 
      error: error.toString() 
    };
  }
}

/**
 * Update a task
 * @param {Object} params - Task update parameters
 * @param {string} params.action_id - Task ID to update (required)
 * @param {string} params.title - New title
 * @param {string} params.priority - New priority
 * @param {string} params.lane - New lane
 * @param {number} params.estimated_minutes - New duration estimate
 * @param {string} params.description - New description
 * @param {string} params.status - New status
 * @return {Object} Result with update status
 */
function appsheet_updateTask(params) {
  try {
    // ensureSystemInitialized();
    if (!params || !params.action_id) {
      throw new Error('action_id is required');
    }
    
    const spreadsheet = getActiveSystemSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAMES.ACTIONS);
    
    if (!sheet) {
      throw new Error('ACTIONS sheet not found');
    }
    
    const data = sheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === params.action_id) {  // action_id column
        const row = i + 1;  // Sheet rows are 1-indexed
        const now = TimeZoneAwareDate.toISOString(new Date());
        
        // Update fields that were provided
        if (params.title !== undefined) {
          sheet.getRange(row, 6).setValue(params.title);  // title column
        }
        if (params.priority !== undefined) {
          sheet.getRange(row, 3).setValue(params.priority);  // priority column
        }
        if (params.lane !== undefined) {
          sheet.getRange(row, 8).setValue(params.lane);  // lane column
        }
        if (params.estimated_minutes !== undefined) {
          sheet.getRange(row, 9).setValue(params.estimated_minutes);  // estimated_minutes column
        }
        if (params.description !== undefined) {
          sheet.getRange(row, 10).setValue(params.description);  // description column
        }
        if (params.status !== undefined) {
          sheet.getRange(row, 2).setValue(params.status);  // status column
        }
        
        // Always update updated_at timestamp
        sheet.getRange(row, 5).setValue(now);  // updated_at column
        
        const logger = getService(SERVICES.SmartLogger);
        logger.log('AppSheetBridge', 'Updated task ' + params.action_id);
        
        return {
          success: true,
          data: { 
            action_id: params.action_id, 
            updated_at: now 
          }
        };
      }
    }
    
    throw new Error('Task not found: ' + params.action_id);
  } catch (error) {
    LoggerFacade.error('AppSheetBridge', 'Function error', {
      function: 'appsheet_updateTask',
      error: error.toString(),
      params: params
    });
    
    return { 
      success: false, 
      error: error.toString() 
    };
  }
}