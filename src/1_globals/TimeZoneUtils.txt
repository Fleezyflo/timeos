/**
 * MOH TIME OS v2.0 - TIMEZONE UTILITIES
 *
 * Centralized timezone-aware date handling with performance optimizations.
 * All date operations in the system should use these utilities for consistency.
 */

class TimeZoneAwareDate {

  /**
   * Convert Date to ISO string with timezone offset
   * Caches results for performance optimization
   */
  static toISOString(date) {
    if (!date || !(date instanceof Date)) {
      // Self-heal invalid dates
      date = new Date();
    }

    // Check for invalid dates
    if (isNaN(date.getTime())) {
      try {
        const logger = container.has(SERVICES.SmartLogger) ?
          container.get(SERVICES.SmartLogger) : { warn: function(c, m) { Logger.log('WARN [' + c + ']: ' + m); }, error: function(c, m) { Logger.log('ERROR [' + c + ']: ' + m); }, log: function(c, m) { Logger.log('LOG [' + c + ']: ' + m); } };
        if (logger.warn) {
          logger.warn('TimeZoneAwareDate', 'Invalid date provided, using current time');
        } else {
          Logger.log('WARN [TimeZoneAwareDate] Invalid date provided, using current time');
        }
      } catch (e) {
        Logger.log('WARN [TimeZoneAwareDate] Invalid date provided, using current time');
      }
      date = new Date();
    }

    // Check cache first
    const cacheKey = date.getTime();
    if (this.cache.has(cacheKey)) {
      this.cacheHits++;
      return this.cache.get(cacheKey);
    }

    this.cacheMisses++;

    try {
      const formatted = Utilities.formatDate(
        date,
        this.timezone,
        "yyyy-MM-dd'T'HH:mm:ssXXX"
      );

      // Cache result with size limit
      this._addToCache(cacheKey, formatted);

      return formatted;

    } catch (error) {
      try {
        const logger = (typeof container !== 'undefined' && container.has && container.has(SERVICES.SmartLogger)) ?
          container.get(SERVICES.SmartLogger) : { error: function(c, m) { Logger.log('ERROR [' + c + ']: ' + m); } };
        logger.error('TimeZoneAwareDate', `Formatting failed: ${error.message}`);
      } catch (logError) {
        Logger.log('ERROR [TimeZoneAwareDate]: Formatting failed: ' + error.message);
      }

      // Fallback to basic ISO with manual timezone
      const offset = this._getTimezoneOffset();
      const isoString = date.toISOString();
      return isoString.replace('Z', offset);
    }
  }

  /**
   * Parse ISO string to Date object with error handling
   */
  static parseISO(dateString) {
    if (!dateString || typeof dateString !== 'string') {
      try {
        const logger = (typeof container !== 'undefined' && container.has && container.has(SERVICES.SmartLogger)) ?
          container.get(SERVICES.SmartLogger) : { warn: function(c, m) { Logger.log('WARN [' + c + ']: ' + m); } };
        logger.warn('TimeZoneAwareDate', 'Invalid date string, using current time');
      } catch (logError) {
        Logger.log('WARN [TimeZoneAwareDate]: Invalid date string, using current time');
      }
      return new Date();
    }

    try {
      // Handle various date formats
      let normalizedString = dateString.trim();

      // If it's just a date, add time
      if (/^\d{4}-\d{2}-\d{2}$/.test(normalizedString)) {
        normalizedString += 'T00:00:00+04:00';
      }

      // If it's missing timezone, add Dubai timezone
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/.test(normalizedString)) {
        normalizedString += '+04:00';
      }

      const parsed = new Date(normalizedString);

      if (isNaN(parsed.getTime())) {
        throw new Error('Invalid date after parsing');
      }

      return parsed;

    } catch (error) {
      const logger = container.get(SERVICES.SmartLogger);
      logger.warn('TimeZoneAwareDate', `Parse failed for: ${dateString} - ${error.message}`);

      // Try alternative parsing methods
      try {
        // Extract date components manually
        const match = dateString.match(/(\d{4})-(\d{2})-(\d{2})/);
        if (match) {
          return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
        }
      } catch (altError) {
        const logger = container.get(SERVICES.SmartLogger);
        logger.error('TimeZoneAwareDate', `Alternative parsing failed: ${altError.message}`);
      }

      // Ultimate fallback
      return new Date();
    }
  }

  /**
   * Get current timestamp as ISO string
   */
  static now() {
    return this.toISOString(new Date());
  }

  /**
   * Get start of day for given date (or today)
   */
  static startOfDay(date = new Date()) {
    const start = new Date(date);
    start.setHours(0, 0, 0, 0);
    return start;
  }

  /**
   * Get end of day for given date (or today)
   */
  static endOfDay(date = new Date()) {
    const end = new Date(date);
    end.setHours(23, 59, 59, 999);
    return end;
  }

  /**
   * Add days to a date
   */
  static addDays(date, days) {
    if (!date || !(date instanceof Date)) {
      date = new Date();
    }

    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  }

  /**
   * Quick check to see if current time matches a trigger window
   */
  static isTimeForTrigger(targetHour, targetMinute = 0) {
    const now = Utilities.formatDate(new Date(), this.timezone, 'HH:mm');
    const currentMinutes = parseInt(now.split(':')[0], 10) * 60 + parseInt(now.split(':')[1], 10);
    const targetMinutes = (targetHour * 60) + targetMinute;
    return Math.abs(currentMinutes - targetMinutes) <= 5;
  }

  /**
   * Compare two dates (returns -1, 0, 1)
   */
  static compare(date1, date2) {
    if (!date1 || !date2) {
      return 0;
    }

    const iso1 = this.toISOString(date1);
    const iso2 = this.toISOString(date2);
    if (iso1 < iso2) return -1;
    if (iso1 > iso2) return 1;
    return 0;
  }

  /**
   * Add hours to a date
   */
  static addHours(date, hours) {
    if (!date || !(date instanceof Date)) {
      date = new Date();
    }

    const result = new Date(date);
    result.setTime(result.getTime() + (hours * CONSTANTS.MILLISECONDS_PER_HOUR));
    return result;
  }

  /**
   * Add minutes to a date
   */
  static addMinutes(date, minutes) {
    if (!date || !(date instanceof Date)) {
      date = new Date();
    }

    const result = new Date(date);
    result.setTime(result.getTime() + (minutes * CONSTANTS.MILLISECONDS_PER_MINUTE));
    return result;
  }

  /**
   * Calculate difference in days between two dates
   */
  static daysBetween(date1, date2) {
    const start = this.startOfDay(date1);
    const end = this.startOfDay(date2);
    const diffTime = Math.abs(end - start);
    return Math.ceil(diffTime / CONSTANTS.MILLISECONDS_PER_DAY);
  }

  /**
   * Calculate difference in hours between two dates
   */
  static hoursBetween(date1, date2) {
    const diffTime = Math.abs(date2 - date1);
    return diffTime / CONSTANTS.MILLISECONDS_PER_HOUR;
  }

  /**
   * Calculate difference in minutes between two dates
   */
  static minutesBetween(date1, date2) {
    const diffTime = Math.abs(date2 - date1);
    return Math.floor(diffTime / CONSTANTS.MILLISECONDS_PER_MINUTE);
  }

  /**
   * Check if two dates are on the same day
   */
  static isSameDay(date1, date2) {
    if (!date1 || !date2) return false;

    return date1.getFullYear() === date2.getFullYear() &&
           date1.getMonth() === date2.getMonth() &&
           date1.getDate() === date2.getDate();
  }

  /**
   * Check if date is today
   */
  static isToday(date) {
    return this.isSameDay(date, new Date());
  }

  /**
   * Check if date is in the past
   */
  static isPast(date) {
    return date < new Date();
  }

  /**
   * Check if date is in the future
   */
  static isFuture(date) {
    return date > new Date();
  }

  /**
   * Format date for display
   */
  static formatForDisplay(date, format = 'yyyy-MM-dd HH:mm') {
    if (!date || !(date instanceof Date)) {
      return '';
    }

    try {
      return Utilities.formatDate(date, this.timezone, format);
    } catch (error) {
      const logger = container.get(SERVICES.SmartLogger);
      logger.error('TimeZoneAwareDate', `Display format failed: ${error.message}`);
      return date.toISOString();
    }
  }

  /**
   * Format time only (HH:mm)
   */
  static formatTime(date) {
    return this.formatForDisplay(date, 'HH:mm');
  }

  /**
   * Format date only (yyyy-MM-dd)
   */
  static formatDate(date) {
    return this.formatForDisplay(date, 'yyyy-MM-dd');
  }

  /**
   * Parse time string (HH:mm) and combine with date
   */
  static combineDateTime(date, timeString) {
    if (!date || !timeString) {
      return new Date();
    }

    const timeParts = timeString.match(/^(\d{1,2}):(\d{2})$/);
    if (!timeParts) {
      const logger = container.get(SERVICES.SmartLogger);
      logger.warn('TimeZoneAwareDate', `Invalid time format: ${timeString}`);
      return new Date(date);
    }

    const result = new Date(date);
    result.setHours(parseInt(timeParts[1]), parseInt(timeParts[2]), 0, 0);
    return result;
  }

  /**
   * Get timezone offset string (+04:00)
   */
  static _getTimezoneOffset() {
    // Dubai is UTC+4
    return '+04:00';
  }

  /**
   * Add to cache with size management
   */
  static _addToCache(key, value) {
    // Limit cache size to prevent memory issues
    if (this.cache.size >= 1000) {
      // Remove oldest 20% of entries
      const keysToRemove = Array.from(this.cache.keys()).slice(0, 200);
      keysToRemove.forEach(k => this.cache.delete(k));
    }

    this.cache.set(key, value);
  }

  /**
   * Get cache statistics
   */
  static getCacheStats() {
    const total = this.cacheHits + this.cacheMisses;
    return {
      hits: this.cacheHits,
      misses: this.cacheMisses,
      hitRate: total > 0 ? Math.round((this.cacheHits / total) * 100) + '%' : '0%',
      cacheSize: this.cache.size
    };
  }

  /**
   * Clear cache (for testing or memory management)
   */
  static clearCache() {
    this.cache.clear();
    this.cacheHits = 0;
    this.cacheMisses = 0;
  }

  /**
   * Get week boundaries (Monday to Sunday)
   */
  static getWeekBoundaries(date = new Date()) {
    const monday = new Date(date);
    monday.setDate(date.getDate() - (date.getDay() + 6) % 7);
    monday.setHours(0, 0, 0, 0);

    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    sunday.setHours(23, 59, 59, 999);

    return { start: monday, end: sunday };
  }

  /**
   * Get month boundaries
   */
  static getMonthBoundaries(date = new Date()) {
    const start = new Date(date.getFullYear(), date.getMonth(), 1);
    const end = new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59, 999);

    return { start, end };
  }

  /**
   * Check if time is within business hours (9 AM - 6 PM Dubai time)
   */
  static isBusinessHours(date) {
    const hour = date.getHours();
    return hour >= 9 && hour < 18;
  }

  /**
   * Get next business day (skips weekends)
   */
  static getNextBusinessDay(date = new Date()) {
    const next = this.addDays(date, 1);

    // Skip weekends (Saturday = 6, Sunday = 0)
    while (next.getDay() === 0 || next.getDay() === 6) {
      next.setDate(next.getDate() + 1);
    }

    return next;
  }

  /**
   * Create date from components with validation
   */
  static createDate(year, month, day, hour = 0, minute = 0, second = 0) {
    try {
      // Validate components
      if (year < 1900 || year > 2100) throw new Error('Invalid year');
      if (month < 1 || month > 12) throw new Error('Invalid month');
      if (day < 1 || day > 31) throw new Error('Invalid day');
      if (hour < 0 || hour > 23) throw new Error('Invalid hour');
      if (minute < 0 || minute > 59) throw new Error('Invalid minute');
      if (second < 0 || second > 59) throw new Error('Invalid second');

      return new Date(year, month - 1, day, hour, minute, second);

    } catch (error) {
      const logger = container.get(SERVICES.SmartLogger);
      logger.error('TimeZoneAwareDate', `Create date failed: ${error.message}`);
      return new Date();
    }
  }
}

TimeZoneAwareDate.timezone = CONSTANTS.TIMEZONE;
TimeZoneAwareDate.cache = new Map(); // Cache formatted dates for performance
TimeZoneAwareDate.cacheHits = 0;
TimeZoneAwareDate.cacheMisses = 0;

